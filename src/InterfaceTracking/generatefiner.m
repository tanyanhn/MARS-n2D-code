function [pts,add,area] = generatefiner(spline1,spline2,radius)
%%%%%%%%%%%%%%%%%%%%%
% Input Parameters  %
%%%%%%%%%%%%%%%%%%%%%
%
% xsp1,ysp1 : the coarser splinegon in pp form,
% xsp2,ysp2 : the finer splinegon in pp form,
% radius    : 两个样条曲线间对应点间距离的上界，不能太大。
%%%%%%%%%%%%%%%%%%%%%
% Output Parameters %
%%%%%%%%%%%%%%%%%%%%%
%
%  pts: new finer pts after vertical alignment
%  add: the points generated by vertical alignment
%  area: the approx xorarea between the coarser pts and the finer pts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

xsp1 = spline1.xsp;
ysp1 = spline1.ysp;
xsp2 = spline2.xsp;
ysp2 = spline2.ysp;

% the parameters of the two splinegons.
t1 = fnbrk(xsp1, 'breaks');
t2 = fnbrk(xsp2, 'breaks');
if t1(1)~=0 || t2(1)~=0
    error('The parametrization of both splines must start from 0!');
end
nV1 = length(t1)-1;
nV2 = length(t2)-1;
dt1 = t1(2:end)-t1(1:end-1);
dt2 = t2(2:end)-t2(1:end-1);
maxdt = max(max(dt1), max(dt2));

xcf2 = fnbrk(xsp2, 'coefs');
ycf2 = fnbrk(ysp2, 'coefs');

v1 = [fnval(xsp1,t1); fnval(ysp1,t1)];
v2 = [fnval(xsp2,t2); fnval(ysp2,t2)];

%%
% plot(v1(1,:),v1(2,:),'b-');
% axis equal;
% hold on;
% plot(v2(1,:),v2(2,:),'g-');

dxdt1 = fnder(xsp1);
dydt1 = fnder(ysp1);


gauss_weight = [1 / 36 * (18 - sqrt(30)), ...
    1 / 36 * (18 + sqrt(30)), ...
    1 / 36 * (18 + sqrt(30)), ...
    1 / 36 * (18 - sqrt(30))];
gauss_absc  = [-1 / 35 * sqrt(525 + 70 * sqrt(30)), ...
    -1 / 35 * sqrt(525 - 70 * sqrt(30)), ...
    1 / 35 * sqrt(525 - 70 * sqrt(30)), ...
    1 / 35 * sqrt(525 + 70 * sqrt(30))];
            
dif_t = diff(t1) / 2;
ave_t = 0.5 * (t1(1:end-1) + t1(2:end));
absc = gauss_absc' * dif_t + ave_t;
ds = gauss_weight * sqrt(fnval(fnder(xsp1),absc).^2 + fnval(fnder(ysp1), absc).^2);
ds = ds .* dif_t ;

t2tmp = t2;
add = [];
delta = [];

for i=1:nV1
   pts1 = v1(:,i); 
   grad1 = [fnval(dydt1,t1(i)),-fnval(dxdt1,t1(i))];
   grad1 = grad1/norm(grad1,2);
   line = [pts1(1)-radius*grad1(1),pts1(1)+radius*grad1(1);...
       pts1(2)-radius*grad1(2),pts1(2)+radius*grad1(2)];
%    plot(line(1,:),line(2,:),'r -');
   
   [X0,Y0,ij] = polyxpoly(line(1,:), line(2,:), v2(1,:), v2(2,:));
   ids = ij(:,2);
   if length(ids)>1
      XY = [X0-pts1(1),Y0-pts1(2)];%这里选取最近节点用线性近似会不会出问题
      dist = XY(:,1).^2+XY(:,2).^2;
      [~,idss] = min(dist);
      ids = ids(idss);
      X0 = X0(idss);%
      Y0 = Y0(idss);%
   end
   if equal([X0;Y0],v2(:,ids),norm(v2(:,ids)-v2(:,ids+1),2))
       %add = [add,v2(:,ids)];
       pts2 = v2(:,ids);
       dpts = pts2 - pts1;%
       %plot(v2(1,ids),v2(2,ids),'y o');
   elseif equal([X0;Y0],v2(:,ids+1),norm(v2(:,ids)-v2(:,ids+1),2))
       %add = [add,v2(:,ids+1)];
       pts2 = v2(:,ids+1);
       dpts = pts2 - pts1;%
       %plot(v2(1,ids+1),v2(2,ids+1),'y o');
   else
       xcf = xcf2(ids,:);
       ycf = ycf2(ids,:);
       if equal(grad1(1),0,norm(grad1,2))
           xcf(end) = xcf(end)-pts1(1);
           t = realRootsInInterval(xcf,0,t2(ids+1)-t2(ids));
           t = t + t2(ids);
           pts2 = [fnval(xsp2,t);fnval(ysp2,t)];
           dpts = pts2 - pts1;
       elseif equal(grad1(2),0,norm(grad1,2))
           ycf(end) = ycf(end) - pts1(2);
           t = realRootsInInterval(ycf,0,t2(ids+1)-t2(ids));
           t = t + t2(ids);
           pts2 = [fnval(xsp2,t);fnval(ysp2,t)];
           dpts = pts2 - pts1;
       else
           k = grad1(2)/grad1(1);
           ycf(end) = ycf(end)-pts1(2);
           xcf(end) = xcf(end)-pts1(1);
           coef = ycf-k*xcf;
           t = realRootsInInterval(coef,0,t2(ids+1)-t2(ids));
           t = t + t2(ids);
           pts2 = [fnval(xsp2,t);fnval(ysp2,t)];
           dpts = pts2 - pts1;
       end
       if isempty(t) || length(t)>1
           disp('error');
       end
       %t = t2(ids)+t;
       ids2 = find(t2tmp<t,1,'last');
       t2pre = t2tmp(1:ids2);
       t2aft = t2tmp(ids2+1:end);
       t2tmp = [t2pre,t,t2aft];
       %pts2 = [fnval(xsp2,t);fnval(ysp2,t)];
       %plot(pts2(1),pts2(2),'black*');
%        if sign == 1
%            sign
%        end
       %add = [add,pts2];
   end
   if equal(grad1(1),0,norm(grad1,2))
       if dpts(2)/grad1(2)>0
           sign = 1;
       else
           sign = -1;
       end
   else
       if dpts(1)/grad1(1)>0
           sign = 1;
       else
           sign = -1;
       end
   end
   %%
%    if norm(pts1,2)>=norm(pts2,2)
%        sign = 1;
%    else
%        sign = -1;
%    end
   add = [add,pts2];
   delta = [delta,norm(dpts,2)*sign];%
   %plot(fnval(xsp2,t),fnval(ysp2,t),'y o');
end

area = 0;
for i=1:nV1-1
    if delta(i)*delta(i+1)>0
    area = area+abs(delta(i)+delta(i+1))/2*ds(i);
    elseif delta(i)*delta(i+1)==0
    else
        area = area+(delta(i)^2+delta(i+1)^2)*ds(i)/2/(abs(delta(i))+abs(delta(i+1)));
    end
end
if delta(end)*delta(1)>0
    area = area+abs(delta(end)+delta(1))/2*ds(nV1);
else
    area = area+(delta(end)^2+delta(1)^2)*ds(nV1)/2/(abs(delta(end))+abs(delta(1)));
end

add = [add,add(:,1)];
pts = [fnval(xsp2,t2tmp);fnval(ysp2,t2tmp)];

end

function r = realRootsInInterval(p, t0, te)
% return the roots of a polynomial p(t) within the interval [t0, te]

r=[];
rts = roots(p)';
for i=1:length(rts)
    if ~isreal(rts(i))
        rts(i) = 2*te-t0;
    end
end
% limit the roots to this interval
tid = find(rts>=t0 & rts<=te);
if ~isempty(tid)
    r = rts(tid);
end
end
