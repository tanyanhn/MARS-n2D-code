---
description: 
globs: **/*.c,**/*.cpp,**/*.h,**/*.hpp,**/*.cxx,CMakeLists.txt,*.cmake,conanfile.txt,Makefile,**/*.cc
alwaysApply: false
---
# C++ 编程规范

## 基本原则

- 代码和文档均使用英文编写。
- 始终声明每个变量和函数的类型（包括参数和返回值）。
- 创建必要的类型和类。
- 使用 Doxygen 风格的注释来文档化公共类和方法。
- 函数内部不要留空行。
- 遵循单一定义规则（ODR）。

## 缩进

- 使用2个空格进行缩进，不使用制表符。

## 命名规范

- 类和结构体使用 PascalCase（帕斯卡命名法）。
- 变量、函数和方法使用 camelCase（驼峰命名法）。
- 常量和宏使用 ALL_CAPS（全大写）。
- 文件和目录名使用 PascalCase（帕斯卡命名法）。
- 环境变量使用 UPPERCASE（大写）。
- 避免魔法数字，定义常量。
- 每个函数以动词开头。
- 布尔变量使用动词形式。例如：isLoading、hasError、canDelete 等。
- 使用完整单词而非缩写，确保拼写正确。
  - 标准缩写除外，如 API、URL 等。
  - 常见缩写除外：
    - i、j、k 用于循环
    - err 用于错误
    - ctx 用于上下文
    - req、res 用于请求/响应参数

## 函数

- 编写简短的单一职责函数。少于 20 条指令。
- 函数名以动词和其他词组合命名。
- 如果返回布尔值，使用 isX、hasX、canX 等形式。
- 如果不返回任何值（void），使用 executeX、saveX 等形式。
- 通过以下方式避免嵌套代码块：
  - 提前检查和返回。
  - 提取为工具函数。
- 使用标准库算法（std::for_each、std::transform、std::find 等）避免函数嵌套。
- 简单操作使用 lambda 函数。
- 复杂操作使用命名函数。
- 使用默认参数值而不是检查 null 或 nullptr。
- 使用结构体或类减少函数参数
  - 使用对象传递多个参数。
  - 使用对象返回多个结果。
  - 为输入参数和输出声明必要的类型。
- 使用单一抽象层级。

## 数据

- 不要滥用基本类型，将数据封装在复合类型中。
- 避免在函数中进行数据验证，使用具有内部验证的类。
- 优先使用不可变数据。
- 对不变的数据使用 const。
- 对编译时常量使用 constexpr。
- 对可能为空的值使用 std::optional。

## 类

- 遵循 SOLID 原则。
- 优先使用组合而非继承。
- 将接口声明为抽象类或概念。
- 编写具有单一职责的小类。
  - 少于 200 条指令。
  - 少于 10 个公共方法。
  - 少于 10 个属性。
- 使用五法则（或零法则）进行资源管理。
- 将成员变量设为私有，必要时提供 getter/setter。
- 对成员函数使用 const 正确性。

## 异常处理

- 使用异常处理你不期望的错误。
- 如果捕获异常，应该是为了：
  - 修复预期的问题。
  - 添加上下文信息。
  - 否则，使用全局处理器。
- 对预期的失败使用 std::optional、std::expected 或错误码。

## 内存管理

- 优先使用智能指针（std::unique_ptr、std::shared_ptr）而非原始指针。
- 使用 RAII（资源获取即初始化）原则。
- 通过适当的资源管理避免内存泄漏。
- 使用 std::vector 和其他标准容器而非 C 风格数组。

## 测试

- 测试遵循 Arrange-Act-Assert（准备-执行-断言）约定。
- 清晰命名测试变量。
- 遵循约定：inputX、mockX、actualX、expectedX 等。
- 为每个公共函数编写单元测试。
- 使用测试替身模拟依赖项。
  - 除非第三方依赖项执行成本不高。
- 为每个模块编写集成测试。
- 遵循 Given-When-Then（给定-当-那么）约定。

## 项目结构

- 使用模块化架构
- 将代码组织到逻辑目录中：
  - include/ 用于头文件
  - src/ 用于源文件
  - test/ 用于测试文件
  - lib/ 用于库文件
  - doc/ 用于文档
- 使用 CMake 或类似的构建系统。
- 将接口（.h）与实现（.cpp）分离。
- 使用命名空间逻辑地组织代码。
- 为基础组件创建 core 命名空间。
- 为工具函数创建 utils 命名空间。

## 标准库

- 尽可能使用 C++ 标准库。
- 优先使用 std::string 而非 C 风格字符串。
- 使用 std::vector、std::map、std::unordered_map 等集合类型。
- 使用 std::optional、std::variant、std::any 实现现代类型安全。
- 使用 std::filesystem 进行文件操作。
- 使用 std::chrono 进行时间相关操作。

## 并发编程

- 使用 std::thread、std::mutex、std::lock_guard 实现线程安全。
- 优先使用基于任务的并行而非基于线程的并行。
- 使用 std::atomic 进行原子操作。
- 通过适当的同步避免数据竞争。
- 必要时使用线程安全的数据结构。